{
  "comments": [
    {
      "key": {
        "uuid": "486f8236_1d3f634c",
        "filename": "call/call.cc",
        "patchSetId": 9
      },
      "lineNbr": 372,
      "author": {
        "id": 5509
      },
      "writtenOn": "2019-08-09T23:44:51Z",
      "side": 1,
      "message": "I don\u0027t understand this comment, and neither does trunk clang (https://bugs.chromium.org/p/chromium/issues/detail?id\u003d992640). Can you expand on this a bit? Why isn\u0027t putting transport_send_ last and using that everywhere we currently use transport_send_prt_ sufficient?",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6e3748df_6f7032dd",
        "filename": "call/call.cc",
        "patchSetId": 9
      },
      "lineNbr": 372,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-08-12T07:27:20Z",
      "side": 1,
      "message": "This was a while ago. If I remember correctly, the issues was related to the fact that unique_ptr will set the member to nullptr _before_ deleting the member. That meant that the task queue in RTCS would continue running even as it was being destroyed, meaning that it would continue issuing callbacks that, due to unlucky circumstances, would access members of RTCS causing segfaults due to null pointer access.\n\nIt\u0027s possible that this no longer can happen doe to restructuring of the code and that this therefore could be improved. An option would be to add a custom deleter that avoids this issue. I\u0027m not sure that would be more readable, but it avoids a compiler error it might be a reasonable tradeoff?",
      "parentUuid": "486f8236_1d3f634c",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "554a84a2_f3a550e8",
        "filename": "call/call.cc",
        "patchSetId": 9
      },
      "lineNbr": 600,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T09:57:46Z",
      "side": 1,
      "message": "this feels strange. The worker queue, according to comments that previously were in this file, was meant to replace module_process_thread_. Now the TQ has been moved into a different class, but module_process_thread_ is still here. Further still here, we\u0027re fetching a pointer to a member variable owned by transport_send_ptr_, and giving it to an object that\u0027s not directly aware of the lifetime of the queue or how it\u0027s managed.\n\nIs there a design doc or something that explains these architectural changes? On the surface, it seems like a step backwards to me but I\u0027m probably missing something.",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "150a610b_5efdf0b5",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T09:57:46Z",
      "side": 1,
      "message": "is holding this lock absolutely necessary? We\u0027re posting a task to a queue and then grabbing the lock there, which seems bad. Further still holding the lock while making a call to an external implementation also doesn\u0027t seem good.",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7dd1b1a_1ab02cb4",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-06-04T10:43:34Z",
      "side": 1,
      "message": "It would be nice if observer_ were a construction time const, but it isn\u0027t, due to the order things are created, iirc. But it can only change to a non-null value once, so it should be safe to read it out and release the lock (assuming the observer takes responsibility for any additional synchronization it might need internally).",
      "parentUuid": "150a610b_5efdf0b5",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c574456a_ace03bf7",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T11:26:08Z",
      "side": 1,
      "message": "Under what circumstance could the pointer be null here?\nThings to consider:\n- We\u0027re not on the TQ. What thread are we on? (same as ctor thread perhaps?)\n- When the task executes, what exactly is the race we\u0027re guarding against with the lock? Can it happen?\n\nIf the race can\u0027t happen, then let\u0027s remove the lock and document + dcheck the expectations.",
      "parentUuid": "e7dd1b1a_1ab02cb4",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25d9c0c2_a8904a82",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-06-04T11:49:51Z",
      "side": 1,
      "message": "The observer is Call, and the observer_ pointer is set in RtpTransportControllerSend::RegisterTargetTransferRateObserver, only call from Call\u0027s constructor (so this link implies a circular references between Call and RtpTransportControllerSend).\n\nNot sure if anything will break if RegisterTargetTransferRateObserver is changed to post a task to update the pointer. Sebastian?",
      "parentUuid": "c574456a_ace03bf7",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93a8f19b_578c2161",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 101,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T11:26:08Z",
      "side": 1,
      "message": "we never dcheck for a pointer that we dereference anyway",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b87d16b2_fed2cc7c",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 108,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T09:57:46Z",
      "side": 1,
      "message": "duplicated code?",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "49cca977_f717a94d",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 108,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T11:26:08Z",
      "side": 1,
      "message": "this bit is identical to the code block above, so should be moved to a separate function so that both places won\u0027t have to be updated or fall out of sync. Also, there, the appropriate checks + documentation can be kept in one place.",
      "parentUuid": "b87d16b2_fed2cc7c",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c5ab92ed_1957ae65",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 113,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T09:57:46Z",
      "side": 1,
      "message": "having this getter here, feels to me like the ownership of the TQ actually belongs elsewhere. A worker queue seems more generic than something explicitly owned by a transport send controller.",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c73de11a_60a7ec61",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 113,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-06-04T10:43:34Z",
      "side": 1,
      "message": "The idea is that the task queue is used for things related to the RTP send streams, but currently done by VideoSendStream. Ownership in the RtpTransportControllerSend makes sense if this responsibility for those operations are also moved to methods in this class.\n\nThe module_process_thread_, owned by Call, is also passed down on the send side, where it\u0027s used to drive the rtp_rtcp modules. That\u0027s responsibility that should belong with RtpTransportControllerSend, even though they\u0027re currently far apart.",
      "parentUuid": "c5ab92ed_1957ae65",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "324c6f30_3d3fff75",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 113,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-06-04T11:26:08Z",
      "side": 1,
      "message": "As is, the TQ pointer is being handed out to AudioSendStream and VideoSendStream from inside of call.cc. Do you mean that those instances should belong to (or at least created by) RtpTransportControllerSend instead of Call?",
      "parentUuid": "c73de11a_60a7ec61",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "144b8e96_b8f7859f",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 9
      },
      "lineNbr": 113,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-06-04T11:49:51Z",
      "side": 1,
      "message": "\u003e As is, the TQ pointer is being handed out to AudioSendStream and VideoSendStream from inside of call.cc. Do you mean that those instances should belong to (or at least created by) RtpTransportControllerSend instead of Call?\n\nThe idea is that RtpTransportControllerSend should encapsulate everything the send stream needs to know about the Rtp transport. RtpTransportControllerSend is passed by Call to the send stream constructors, for this purpose. Now, they also get a pointer to the TQ (and to the module_process_thread). \n\nWhat I mean is that wherever the a send stream posts something directly to this taskqueue, we should design a method on RtpTransportControllerSend (or some per-stream class it\u0027s in control of) to perform the needed operation, and possibly post on the task queue internally.\n\nA possible next step (discussed earlier on this cl) is to delete the tq argument and the GetWorkerQueue call from Call, and instead let the send streams call GetWorkerQueue when they have something to post. I think it\u0027s preferable to move GetWorkerQueue closer to where it is needed.",
      "parentUuid": "324c6f30_3d3fff75",
      "revId": "e6256055e7db560da560829a3e249898f9685d1f",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}